<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Alchemist Software</title>
    <link rel="icon" href="./favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/style.css">
</head><body>
<div class="right-left-margin-container">
    <h1 class="fancy-header">Alchemist Software</h1>
    <nav class="navbar">
        <a href="/index.html">Home</a>
        <a href="/pages/posts.html">Posts</a>
        <a href="/pages/projects.html">Projects</a>
        <a href="/pages/about.html">About</a>
        <a href="/pages/contact.html">Contact</a>
    </nav>
</div>
<div id="activity"></div>
<p id="canvas-container">
    <canvas id="canvas" width="900" height="600"></canvas>
</p>
<p id="copyright">Copyright Alchemist Software LLC 2023</p></body>
</html>

<script>
async function getGithubEvents() {
    let promise = new Promise((resolve) => {
        fetch(`https://api.github.com/users/cabarger/events/public`)
            .then((Response) => {
                Response.text()
                .then((response_json) => {
                    caleb_github_events = JSON.parse(response_json);
                    resolve(caleb_github_events);
                });
            });
    });
    return promise;
}

// const activity_element = document.getElementById("activity"); 
// getGithubEvents().then(events => {
//   events.forEach((event) => {
//     if (event.type == "PushEvent") {
//       let card = document.createElement("div");
//       card.className = "card"

//       let push_info = document.createElement("p");
//       push_info.innerHTML = event.created_at.slice(0, 10) + ": pushed " + event.payload.commits.length + " commits to " + `<a href="https://github.com/${event.repo.name}">${event.repo.name}</a>`;
//       card.appendChild(push_info);
//       event.payload.commits.forEach((commit) => {
//         let commit_message = document.createElement("p");
//         commit_message.innerHTML = commit.message;
//         card.appendChild(commit_message);
//       });
//       activity_element.appendChild(card);
//     }
//   });
// });

// NOTE(caleb): Why does this exist? 09/05/23 -- Funner than doing my math homework.
// Tetris -----------------------------------------------------------------------------------------

const ROWS = 20;
const COLS = 20;
const BLOCK_STR = "â– ";
const TETRONIMO_DATA = [
    [
        1, 0, 0, 0, // Straight
        1, 0, 0, 0,
        1, 0, 0, 0,
        1, 0, 0, 0 
    ], 
    [
        1, 1, 0, 0, // Square
        1, 1, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, 0 
    ], 
    [
        1, 1, 1, 0, // T
        0, 1, 0, 0,
        0, 0, 0, 0,
        0, 0, 0, 0 
    ], 
    [
        1, 0, 0, 0, // L
        1, 0, 0, 0,
        1, 1, 0, 0,
        0, 0, 0, 0 
    ], 
    [
        0, 0, 0, 0, // Skew
        0, 0, 0, 0,
        0, 1, 1, 0,
        1, 1, 0, 0 
    ], 
];

const Tetronimo = {
    straight: 0,
    square: 1,
}; 

const Orientation = {
    up: 0,
    right: 1,
    down: 2,
    left: 3,
};

function rotate(piece_buffer) {
    result = []
    for (let row_index=0; row_index < 4; ++row_index) { 
        for (let col_index=0; col_index < 4; ++col_index) {
            result.push(0);
        }
    }

    for (let row_index=0; row_index < 4; ++row_index)  {
        for (let col_index=0; col_index < 4; ++col_index) {
            result[row_index * 4 + col_index] = piece_buffer[(4 - (col_index + 1)) * 4 + row_index];
        }
    }

    return result;
}

function draw(ctx, board, active_tetro, block_dim) {
    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, 900, 600); 

    // Draw board border
    // ctx.fillStyle = "#2e4229"; // Cool old schoolish green
    ctx.fillStyle = "white";

    // Horizontal border
    for (let row_index=0; row_index < ROWS + 1; ++row_index)  {
        ctx.fillText("!<", 0, block_dim[1] * (row_index + 1));
        ctx.fillText(">!", COLS*block_dim[0] + block_dim[0] * 2, block_dim[1] * (row_index + 1));
    }
    // Vertical border
    for (let col_index=0; col_index < COLS; ++col_index) {
        ctx.fillText("=", col_index * block_dim[0] + block_dim[0] * 2, block_dim[1] * (ROWS + 1));
        if (col_index % 2 === 0) 
            ctx.fillText("\\", col_index * block_dim[0] + block_dim[0] * 2, block_dim[1] * (ROWS + 2));
        else 
            ctx.fillText("/", col_index * block_dim[0] + block_dim[0] * 2, block_dim[1] * (ROWS + 2));
    }

    
    // Active tetronimo
    let piece_buffer = []
    for (let row_index=0; row_index < 4; ++row_index)  {
        for (let col_index=0; col_index < 4; ++col_index)  {
            piece_buffer[row_index * 4 + col_index] = 
                TETRONIMO_DATA[active_tetro.type][row_index * 4 + col_index];
        }
    }
    for (let ori_index=0; ori_index < active_tetro.ori; ++ori_index) 
        piece_buffer = rotate(piece_buffer);
    for (let row_index=0; row_index < 4; ++row_index) { 
        for (let col_index=0; col_index < 4; ++col_index) { 
            if (piece_buffer[row_index * 4 + col_index])
                ctx.fillText(BLOCK_STR, (active_tetro.col + col_index) * block_dim[0] + block_dim[0] * 2, block_dim[1] * (active_tetro.row + row_index + 1));
        }
    }
    
    // Board blocks
    for (let row_index=0; row_index < ROWS; ++row_index)  {
        for (let col_index=0; col_index < COLS; ++col_index) {
            if (board[row_index * COLS + col_index] != 0) {
                ctx.fillText(BLOCK_STR, col_index * block_dim[0] + block_dim[0] * 2, block_dim[1] * (row_index + 1));
            } else if (col_index % 2 == 1) {  
                if ((row_index >= active_tetro.row && row_index < active_tetro.row + 4) && 
                    (col_index >= active_tetro.col && col_index < active_tetro.col + 4) && 
                    (piece_buffer[(row_index - active_tetro.row) * 4 + (col_index - active_tetro.col)]))
                        continue;
                ctx.fillText(".", col_index * block_dim[0] + block_dim[0] * 2, block_dim[1] * (row_index + 1));
            }
        }
    }

}

const ctx = document.getElementById("canvas").getContext("2d");
ctx.font = "32px sans-serif";
const block_text_metrics = ctx.measureText(BLOCK_STR);
const block_width = block_text_metrics.width;
const block_height = block_text_metrics.actualBoundingBoxAscent;
const block_dim = [block_width, block_height];

const board = [];
for (let row_index=0; row_index < ROWS; ++row_index)  {
    for (let col_index=0; col_index < COLS; ++col_index) {
        board.push(0);
    }
}

const active_tetro = {
    ori: Orientation.up,
    type: Tetronimo.straight,  
    row: 3,
    col: 0,
};

draw(ctx, board, active_tetro, block_dim); // Initial draw
setInterval(() => { // Game loop
    // active_tetro.row += 1;
    active_tetro.ori = ((active_tetro.ori + 1) % 4);
    draw(ctx, board, active_tetro, block_dim);
}, 1000);

</script>
